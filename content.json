{"meta":{"title":"GreatLuis","subtitle":"","description":"Because Love You Everyday","author":"Mr.Liu","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"1.特征工程","slug":"特征工程","date":"2020-08-07T05:21:25.000Z","updated":"2020-08-11T13:01:03.608Z","comments":true,"path":"2020/08/07/特征工程/","link":"","permalink":"http://yoursite.com/2020/08/07/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"第一章 特征工程引言数据和特征决定了结果的上限，模型、算法的选择以及优化则是在逐步接近这个上下限；特征工程是对原始数据进行一系列工程处理，将其提炼为特征，作为输入供算法和模型使用，旨在去除原始数据中的杂质和冗余，设计更高效的特征来刻画求解的问题与预测模型之间的关系；数据类型分为：1.结构化数据（key-value）；2.非结构化数据（picture、video） 01 特征归一化 Why？ 1.消除数据特征之间的量纲影响，使得不同指标的数据之间具有可比性；2.通过梯度下降法求解的模型通常需要归一化，因为归一化可以将各个特征映射到同一个区间下，使得各个特征的收敛速度变得尽可能一直，容易更快通过梯度下降找到最优解，但是对于决策树是不适用的！（决策树在进行节点分裂时主要依据数据集D关于特征x的信息增益比，这个是与特征是否经过归一化是无关的）有图为证： How？ 1.Min-Max Scaling$$Xnorm=\\frac{X-Xmin}{Xmax-Xmin}$$2.Z-Score Normalization$$z=\\frac{x-μ}{σ}$$ 02 类别型特征","categories":[],"tags":[{"name":"百面机器学习","slug":"百面机器学习","permalink":"http://yoursite.com/tags/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"内部类","slug":"内部类","date":"2020-08-07T05:21:25.000Z","updated":"2020-08-11T13:38:22.582Z","comments":true,"path":"2020/08/07/内部类/","link":"","permalink":"http://yoursite.com/2020/08/07/%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"","text":"JAVA内部类1.内部类基础· 内部类定义：将一个类定义在另一个类里或者一个方法里· 内部类分类：成员内部类，局部内部类，匿名内部类，静态内部类y1s1，这个内看多了好像一个肉，饿了。 1.1 成员内部类成员内部类是最普通的内部类，定义在另外一个类的里面，如下： 12345678910111213class Rectangle&#123; private double height = 0; private double width = 0; public Rectangle(double h,double w)&#123; height = h; width = w; &#125; class Draw&#123; public void drawShape()&#123; System.out.println(&quot;drawShape&quot;); &#125; &#125;&#125; 类Draw像是类Rectangle的一个成员，Rectangle称为外部类；内部类可以无条件地访问外部类的所有成员属性和方法（private 和 static），因为内部类里隐式含有指向外部类的一个引用(outer.this)；但是如果内部类里面含有和外部类相同名字的方法或者成员变量时候，要指明作用域，否则默认的·是访问成员内部类；如何指明： 12outer.this.成员变量;outer.this.成员方法; 在外部类中如果想访问内部类的成员，不是那么容易，方法为：通过创建一个成员内部类的对象，再通过指向这个对象的引用来访问： 123456789101112131415161718 class Rectangle&#123; private double height = 0; private double width = 0; public Rectangle(double h,double w)&#123; height = h; width = w; getDrawInstance().drawShape(); //通过对象调用方法 &#125; private Draw getDrawInstance()&#123; return new Draw(); //创建一个对象 &#125; class Draw&#123; public void drawShape()&#123; System.out.println(&quot;The rectangle&#x27;s height is: &quot; + height); System.out.println(&quot;The rectangle&#x27;s width is: &quot; + width); &#125; &#125;&#125; 成员内部类的对象必须依托外部类来创建，有两种方法，如下所示： 12345678910111213141516171819202122232425public class Test&#123; public static void main(String[] args)&#123; Rectangle rectangle = new Rectangle(20,20); Rectangle.Draw draw = rectangle.new Draw(); //第一种方法通过 outer.new 来创建内部类对象 Rectangle.Draw draw1 = rectangle.getDrawInstance(); //第二种方法，通过外部类的对象创建方法来创建内部类对象 &#125;&#125;class Rectangle&#123; private double height = 0; private double width = 0; public Rectangle(double h,double w)&#123; height = h; width = w; getDrawInstance().drawShape(); &#125; public Draw getDrawInstance()&#123; return new Draw(); //这边是public了 &#125; class Draw&#123; public void drawShape()&#123; System.out.println(&quot;The rectangle&#x27;s height is: &quot; + height); System.out.println(&quot;The rectangle&#x27;s width is: &quot; + width); &#125; &#125;&#125; 成员内部类可以拥有private、protected、public以及package访问权限；外部类只有public和package访问权限； 1.2 局部内部类","categories":[],"tags":[{"name":"Thinking in JAVA","slug":"Thinking-in-JAVA","permalink":"http://yoursite.com/tags/Thinking-in-JAVA/"}]},{"title":"helloL","slug":"helloL","date":"2020-08-03T09:21:25.000Z","updated":"2020-08-03T11:31:01.787Z","comments":true,"path":"2020/08/03/helloL/","link":"","permalink":"http://yoursite.com/2020/08/03/helloL/","excerpt":"","text":"开始 水哥博客开始营业了！","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"百面机器学习","slug":"百面机器学习","permalink":"http://yoursite.com/tags/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Thinking in JAVA","slug":"Thinking-in-JAVA","permalink":"http://yoursite.com/tags/Thinking-in-JAVA/"}]}